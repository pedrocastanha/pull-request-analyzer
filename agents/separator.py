import logging
import json
import re
from typing import Dict, List, Any
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.messages import HumanMessage

from messages import SeparatorAgent
from settings import SharedSettings
from models.pr_state import PRState
from schemas import SeparatorResult, Module

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    force=True
)
logger = logging.getLogger(__name__)

llm = ChatGoogleGenerativeAI(
    model=SharedSettings.GEMINI_MODEL,
    temperature=0.1,  # Baixa temperatura para an√°lise mais consistente
    google_api_key=SharedSettings.GEMINI_API_KEY,
    convert_system_message_to_human=True
)

def build_separator_prompt(state: PRState) -> str:
    """Constr√≥i o prompt para o agente separador"""
    
    files_context = ""
    for i, file_change in enumerate(state.files_changed, 1):
        files_context += f"\n{i}. **{file_change.filename}**\n"
        files_context += f"   - Status: {file_change.status}\n"
        files_context += f"   - Mudan√ßas: +{file_change.additions}/-{file_change.deletions} linhas\n"
        
        if file_change.after_content:
            # Mostra apenas as primeiras linhas para an√°lise de imports
            content_preview = file_change.after_content[:1000]
            files_context += f"   - Conte√∫do (preview):\n```\n{content_preview}\n```\n"
        
        if file_change.patch:
            files_context += f"   - Patch (preview):\n```\n{file_change.patch[:500]}\n```\n"

    return f"""
Analise os arquivos modificados neste Pull Request e agrupe-os em m√≥dulos baseados em suas depend√™ncias e intera√ß√µes.

**PR:** {state.pr_title}
**Reposit√≥rio:** {state.repo_owner}/{state.repo_name}
**Total de arquivos:** {len(state.files_changed)}

**Arquivos modificados:**
{files_context}

**Instru√ß√µes:**
1. Analise as depend√™ncias entre os arquivos (imports, requires, etc.)
2. Identifique arquivos que trabalham juntos funcionalmente
3. Agrupe arquivos relacionados em m√≥dulos l√≥gicos
4. Se um arquivo n√£o depende de outros, ele forma um m√≥dulo independente

Retorne APENAS um JSON v√°lido com a estrutura especificada no prompt do sistema.
"""

async def separator_node(state: PRState) -> PRState:
    """N√≥ do agente separador que agrupa arquivos em m√≥dulos"""
    logger.info("üîç Iniciando an√°lise de separa√ß√£o de arquivos")
    state.update_progress("Separando arquivos em m√≥dulos", 10.0)
    
    try:
        # Constr√≥i o prompt com contexto dos arquivos
        prompt = build_separator_prompt(state)
        
        # Cria a mensagem para o LLM
        messages = [
            HumanMessage(content=prompt)
        ]
        
        # Executa a an√°lise
        response = await llm.ainvoke(messages)
        
        # Parse do resultado JSON
        separator_result = parse_separator_response(response.content)
        state.separator_result = separator_result
        
        state.log(f"‚úÖ Separa√ß√£o conclu√≠da: {len(separator_result.modules)} m√≥dulos identificados")
        state.update_progress("Arquivos separados em m√≥dulos", 20.0)
        
        # Log dos m√≥dulos encontrados
        for module in separator_result.modules:
            state.log(f"üì¶ M√≥dulo '{module.name}': {len(module.files)} arquivos ({module.type})")
        
    except Exception as e:
        error_msg = f"Erro na separa√ß√£o de arquivos: {str(e)}"
        state.add_error(error_msg)
        logger.error(error_msg)
    
    return state

def parse_separator_response(content: str) -> SeparatorResult:
    """Parse da resposta do agente separador"""
    try:
        # Tenta extrair JSON da resposta
        json_match = re.search(r'\{.*\}', content, re.DOTALL)
        if json_match:
            data = json.loads(json_match.group())
        else:
            # Fallback: cria um m√≥dulo √∫nico com todos os arquivos
            logger.warning("N√£o foi poss√≠vel extrair JSON v√°lido, criando m√≥dulo √∫nico")
            return create_fallback_modules()
        
        # Valida e converte os dados
        modules = []
        for module_data in data.get("modules", []):
            module = Module(
                id=module_data.get("id", f"module_{len(modules) + 1}"),
                name=module_data.get("name", "M√≥dulo sem nome"),
                files=module_data.get("files", []),
                reason=module_data.get("reason", "Agrupamento autom√°tico"),
                type=module_data.get("type", "independent")
            )
            modules.append(module)
        
        return SeparatorResult(
            modules=modules,
            summary=data.get("summary", "Separa√ß√£o realizada com sucesso")
        )
        
    except Exception as e:
        logger.error(f"Erro ao fazer parse da resposta: {e}")
        return create_fallback_modules()

def create_fallback_modules() -> SeparatorResult:
    """Cria m√≥dulos de fallback quando o parsing falha"""
    modules = [
        Module(
            id="module_1",
            name="Arquivos Modificados",
            files=[],
            reason="Fallback: n√£o foi poss√≠vel analisar depend√™ncias",
            type="independent"
        )
    ]
    
    return SeparatorResult(
        modules=modules,
        summary="Separa√ß√£o realizada com fallback devido a erro no parsing"
    )